/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

%begin %{
	/* GCC 4.7 has a problem with some code generated by SWIG and trigger
	 * a warning. We need to disable it in order to compile properly. */
	#pragma GCC diagnostic ignored "-Warray-bounds"
	#pragma GCC diagnostic ignored "-Wreturn-type"
%}

%{
	#include <haka/error.h>
	#include <haka/lua/lua.h>

	#include <stdlib.h>

	typedef const char *temporary_string;

	#undef SWIG_fail
	#undef SWIG_fail_arg
	#undef SWIG_check_num_args

	#define SWIG_fail {SWIG_arg=-1;goto fail;}
	#define SWIG_fail_arg(func_name,argnum,type) \
	  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
	  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
	  SWIG_arg=-1;goto fail;}
	#define SWIG_check_num_args(func_name,a,b) \
	  if (lua_gettop(L)<a || lua_gettop(L)>b) \
	  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
	  SWIG_arg=-1;goto fail;}
	#define SWIG_execfail {SWIG_arg=-2;goto fail;}

	#define SWIG_lua_always(L, a) 1

	#define _STR_TO_WCS(str)   L##str
	#define STR_TO_WCS(str)   _STR_TO_WCS(str)
%}

%insert("init") %{
	if (luaL_loadstring(L, SWIG_LUACODE)) {
		luaL_error(L, lua_tostring(L, -1));
		lua_pop(L, 1);
		return;
	}

	lua_pushvalue(L, -2);
	if (lua_pcall(L, 1, 0, 0)) {
		luaL_error(L, lua_tostring(L, -1));
		lua_pop(L, 1);
		return;
	}

	return;
%}

%exception %{
	const wchar_t *error;
	$action
	if ((error = clear_error())) {
		int size;
		char *errormb;

		size = wcstombs(NULL, error, 0);
		if (size == (size_t)-1) {
			lua_pushstring(L, "unknown error");
			SWIG_execfail;
		}

		errormb = malloc(size+1);
		if (!errormb) {
			lua_pushstring(L, "memory error");
			SWIG_execfail;
		}

		wcstombs(errormb, error, size+1);
		lua_pushstring(L, errormb);
		free(errormb);

		SWIG_execfail;
	}
%}

%typemap(out) temporary_string {
	lua_pushstring(L, (const char *)$result); SWIG_arg++;
	free((void*)$result);
}

%typecheck(20000) void *ANY {
	$1 = 1;
}

%typemap(in) void *ANY {
	$1 = (void *)lua_topointer(L, $input);
}

%typecheck(20000) char *KEY {
	$1 = 1;
}

%typemap(in) char *KEY {
	size_t len;
	$1 = (char *)lua_converttostring(L, $input, &len);
}

%define STRUCT_UNKNOWN_KEY_ERROR(type)

%extend type {
	void __getitem(char *KEY);
	void __setitem(char *KEY, void *ANY);
}

%{
void type ## ___getitem(struct type *self, char *KEY) {
	error(L"unknown field '%s'", KEY);
}

void type ## ___setitem(struct type *self, char *KEY, void *ANY) {
	error(L"unknown field '%s'", KEY);
}
%}

%enddef

%include "typemaps.i"

%apply bool *OUTPUT { bool *OUTPUT1 };
%apply bool *OUTPUT { bool *OUTPUT2 };
%apply bool *OUTPUT { bool *OUTPUT3 };
%apply bool *OUTPUT { bool *OUTPUT4 };
%apply bool *OUTPUT { bool *OUTPUT5 };
