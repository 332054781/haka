/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*
 * SWIG standard object
 */

%{
#include <haka/lua/object.h>
#include <haka/config.h>

UNUSED static bool lua_object_push_swig(lua_State *L, void *ptr, struct lua_object *obj, swig_type_info *type_info, bool owner)
{
	if (!lua_object_push(L, ptr ? obj : NULL, owner)) {
		SWIG_NewPointerObj(L, ptr, type_info, owner);

		lua_object_register(L, obj, -1, !owner);
	}
	else {
		if (ptr && owner) {
			swig_lua_userdata *usr = (swig_lua_userdata*)lua_touserdata(L, -1);
			assert(usr->own == 0);
			usr->own = 1;
		}
	}
	return true;
}

%}

%define _LUA_OBJECT_IN(typeptr, casttype, name, disown)
	{
		swig_lua_userdata *usr = NULL;

		if (!lua_isnil(L, $input)) {
			usr = (swig_lua_userdata*)lua_touserdata(L, $input);
			assert(!disown || usr->own == 1);
		}

		if (!SWIG_IsOK(SWIG_ConvertPtr(L, $input, (void**)&$1, $descriptor, disown))){
			SWIG_fail_ptr("$symname", $argnum, $descriptor);
		}

		if ($1) {
			lua_object_register(L, &((casttype*)$1)->name, $input, disown);
		}
	}
%enddef

%define _LUA_OBJECT(typeptr, casttype, name)

%typemap(in, checkfn="SWIG_isptrtype") typeptr* {
	_LUA_OBJECT_IN(typeptr, casttype, name, $disown)
}

%typemap(in, checkfn="SWIG_isptrtype") typeptr* DISOWN {
	_LUA_OBJECT_IN(typeptr, casttype, name, SWIG_POINTER_DISOWN)
}

%apply typeptr* DISOWN { typeptr* DISOWN_SUCCESS_ONLY };

%typemap(out) typeptr* {
	if (!lua_object_push_swig(L, $1, &((casttype*)$1)->name, $descriptor, $owner)) {
		SWIG_execfail;
	}
	else {
		SWIG_arg++;
	}
}

%typemap(freearg) typeptr* DISOWN {
	if (SWIG_arg == -1 && $1) {
		if (lua_object_push_swig(L, $1, &((casttype*)$1)->name, $descriptor, 1)) {
			lua_pop(L, 1);
		}
	}
}

%typemap(freearg) typeptr* DISOWN_SUCCESS_ONLY {
	if (SWIG_arg == -2 && $1) {
		if (lua_object_push_swig(L, $1, &((casttype*)$1)->name, $descriptor, 1)) {
			lua_pop(L, 1);
		}
	}
}

%typemap(in,numinputs=0) typeptr** OUTPUT_DISOWN ($*ltype temp)
%{ temp = ($*ltype)0; $1 = &temp; %}

%typemap(argout) typeptr** OUTPUT_DISOWN {
	if ($1) {
		if (!lua_object_push_swig(L, *$1, &(*(casttype**)$1)->name, $*descriptor, 0)) {
			SWIG_execfail;
		}
		else {
			SWIG_arg++;
		}
	}
	else {
		lua_pushnil(L);
		SWIG_arg++;
	}
}

%typemap(in,numinputs=0) typeptr** OUTPUT ($*ltype temp)
%{ temp = ($*ltype)0; $1 = &temp; %}

%typemap(argout) typeptr** OUTPUT {
	if ($1) {
		if (!lua_object_push_swig(L, *$1, &(*(casttype**)$1)->name, $*descriptor, 1)) {
			SWIG_execfail;
		}
		else {
			SWIG_arg++;
		}
	}
	else {
		lua_pushnil(L);
		SWIG_arg++;
	}
}

%enddef


%define LUA_OBJECT_CAST(typeptr, casttype, name)
	_LUA_OBJECT(typeptr, casttype, name)
%enddef

%define LUA_OBJECT(typeptr)
	_LUA_OBJECT(typeptr, typeptr, lua_object)
%enddef

%define LUA_OBJECT_EX(typeptr, name)
	_LUA_OBJECT(typeptr, typeptr, name)
%enddef


/*
 * FFI object
 */

%{

#include <haka/log.h>

UNUSED static bool lua_object_ffi_update_ownership(lua_State *L, int index, bool own)
{
	int h;
	LUA_STACK_MARK(L);
	lua_pushcfunction(L, lua_state_error_formater);
	h = lua_gettop(L);

	if (index < 0) {
		index = h+index;
	}

	lua_getglobal(L, "require");
	lua_pushstring(L, "ffibinding");
	if (lua_pcall(L, 1, 1, h)) {
		lua_state_print_error(L, "ffi");
		lua_pop(L, 2);

		LUA_STACK_CHECK(L, 0);
		return false;
	}

	if (own) {
		lua_getfield(L, -1, "own");
	}
	else {
		lua_getfield(L, -1, "disown");
	}
	lua_pushvalue(L, index);
	if (lua_pcall(L, 1, 0, h)) {
		lua_state_print_error(L, "ffi");
		lua_pop(L, 2);

		LUA_STACK_CHECK(L, 0);
		return false;
	}

	lua_pop(L, 2);
	LUA_STACK_CHECK(L, 0);
	return true;
}

UNUSED static bool lua_object_push_ffi(lua_State *L, void *ptr, struct lua_object *obj, const char *type_info, bool own)
{
	if (!lua_object_push(L, ptr ? obj : NULL, own)) {
		int h;
		LUA_STACK_MARK(L);
		lua_pushcfunction(L, lua_state_error_formater);
		h = lua_gettop(L);

		lua_getglobal(L, "require");
		lua_pushstring(L, "ffi");
		if (lua_pcall(L, 1, 1, h)) {
			lua_state_print_error(L, "ffi");
			lua_pop(L, 1);

			LUA_STACK_CHECK(L, 0);
			return false;
		}

		lua_getfield(L, -1, "cast");
		lua_remove(L, -2);
		lua_pushstring(L, type_info);
		lua_pushlightuserdata(L, ptr);
		if (lua_pcall(L, 2, 1, h)) {
			lua_state_print_error(L, "ffi");
			lua_pop(L, 1);

			LUA_STACK_CHECK(L, 0);
			return false;
		}

		lua_remove(L, -2);

		lua_object_register(L, obj, -1, !own);
		if (own) {
			lua_object_ffi_update_ownership(L, -1, true);
		}

		LUA_STACK_CHECK(L, 1);
	}
	else {
		if (ptr && own) {
			lua_object_ffi_update_ownership(L, -1, true);
		}
	}
	return true;
}

%}

%define _FFI_OBJECT(typeptr, name)

%typemap(in) typeptr * {
	/* cdata is type 10 */
	assert(lua_type(L, $input) == 10);

	typeptr **obj = (typeptr **)lua_topointer(L, $input);
	$1 = *obj;

	if ($1) {
		lua_object_register(L, &($1)->name, $input, $disown);

		if ($disown) {
			lua_object_ffi_update_ownership(L, $input, false);
		}
	}
}

%typemap(in) typeptr *DISOWN {
	/* cdata is type 10 */
	assert(lua_type(L, $input) == 10);

	typeptr **obj = (typeptr **)lua_topointer(L, $input);
	$1 = *obj;

	if ($1) {
		lua_object_register(L, &($1)->name, $input, true);
		lua_object_ffi_update_ownership(L, $input, false);
	}
}

%apply typeptr* DISOWN { typeptr* DISOWN_SUCCESS_ONLY };

%typemap(out) typeptr * {
	if (!lua_object_push_ffi(L, $1, &($1)->name, "typeptr *", $owner)) {
		SWIG_execfail;
	}

	SWIG_arg++;
}

%typemap(freearg) typeptr* DISOWN {
	if (SWIG_arg == -1 && $1) {
		if (lua_object_push_ffi(L, $1, &($1)->name, "typeptr *", 1)) {
			lua_pop(L, 1);
		}
	}
}

%typemap(freearg) typeptr* DISOWN_SUCCESS_ONLY {
	if (SWIG_arg == -2 && $1) {
		if (lua_object_push_ffi(L, $1, &($1)->name, "typeptr *", 1)) {
			lua_pop(L, 1);
		}
	}
}

%enddef

%define FFI_OBJECT(typeptr)
	_FFI_OBJECT(typeptr, lua_object)
%enddef
