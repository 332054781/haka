-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

local class = require('class')

local log = haka.log_section("grammar")

local module = class.class("CComp")

local suffix = "_grammar"

function module.method:__init(name)
	self._name = name..suffix
	self._cfile = haka.config.ccomp.runtime_dir..self._name..".c"
	self._sofile = haka.config.ccomp.runtime_dir..self._name..".so"
	self._parser = nil -- Current parser
	self._parsers = {}

	-- Open and init c file
	self._fd = assert(io.open(self._cfile, "w"))

	-- Create c grammar
	self:write[[
/** File automatically generated by Haka. DO NOT EDIT */
#include <assert.h>

#include <haka/error.h>
#include <haka/lua/lua.h>
#include <haka/lua/state.h>
#include <haka/lua/parse_ctx.h>

#define PARSE_STORE 1
#define PARSE_CTX   2
#define PARSE_INPUT 3

#define FINISH 0

#define RECURS_MAX   200
#define RECURS_NODE  0
#define RECURS_LEVEL 1
]]
end

local function traverse(ccomp, node)
	if ccomp._parser.written_nodes[node] then
		ccomp:jumpto(node)
		return
	end

	local nexts = node:ccomp(ccomp)
	if #nexts == 0 then
		-- Reach one end of the graph
		ccomp:jumptoend()
	end
	for _, iter in pairs(nexts) do
		traverse(ccomp, iter)
	end
end

function module.method:create_parser(name, dgraph)
	self:_start_parser(name)

	traverse(self, dgraph)

	self:_end_parser()
end

function module.method:_start_parser(name)
	assert(not self._parser, "parser already started")
	self._parser = {
		name = name,
		fname = "parse_"..name,
		store = {}, -- Store some lua object to access it from c
		nodes = {}, -- Store all encountered nodes
		nodes_count = 0, -- Count of encountered nodes
		written_nodes = {}, -- Store written nodes
	}
	self._parsers[#self._parsers + 1] = self._parser
	self:write([[

int parse_%s(lua_State *L)
{
	/**
	 * arg1 = store table
	 * arg2 = parse context
	 * arg3 = input
	 */
	int error_formater;
	struct parse_ctx ctx;
	parse_ctx_init(&ctx);

	assert(lua_istable(L, PARSE_STORE));

	lua_pushcfunction(L, lua_state_error_formater);
	error_formater = lua_gettop(L);

	while(ctx.run) { switch(ctx.node) {
]], name)
end

function module.method:_end_parser()
	assert(self._parser, "parser not started")
	self:write([[
	default: /* node 0 is default and is also exit */
	{
		ctx.run = false;
	}
	} }

	lua_getfield(L, PARSE_CTX, "_results"); /* get ctx._results */
	lua_rawgeti(L, -1, 1);                  /* result stand first in table */
	lua_remove(L, -2);                      /* remove ctx._results */

	parse_ctx_free(&ctx);

	return 1;
}
]], self._parser.name)
	self._parser = nil
end

function module.method:store(obj)
	assert(self._parser, "parser not started")
	assert(obj, "cannot store nil")
	local id = #self._parser.store + 1

	self._parser.store[id] = obj
	return id
end

function module.method:push_stored(id, name)
	name = name or "anonymous stored object"
	self:write([[
		lua_rawgeti(L, PARSE_STORE, %d);          /* get %s */
]], id, name)
end

function module.method:register(node)
	self._parser.nodes_count = self._parser.nodes_count + 1
	self._parser.nodes[node] = self._parser.nodes_count
	return self._parser.nodes_count
end

function module.method:start_node(node)
	assert(self._parser, "parser not started")
	local rule = node.rule or "<unknown>"
	local field = node.id
	if node.name then
		field = string.format("'%s'", node.name)
	end
	local type = class.classof(node).name
	-- Register node if it is not
	local id = self._parser.nodes[node]
	if not id then
		id = self:register(node)
	end

	-- Mark as written
	self._parser.written_nodes[node] = true

	self:write([[

	/* gid %d */
	case %d: /* in rule '%s' field %s <%s> */
	{
]], node.gid, id, rule, field, type)
end

function module.method:finish_node()
	assert(self._parser, "parser not started")
	self:write[[
	}
]]
end

function module.method:pcall(nargs, nresults, fname)
	assert(self._parser, "parser not started")
	fname = fname or "anonymous function"
	self:write([[
		if (lua_pcall(L, %d, %d, error_formater)) { /* %s */
			lua_state_print_error(L, "_parse");
			return 0;
		}
]], nargs, nresults, fname)
end

function module.method:jumpto(node)
	assert(self._parser, "parser not started")
	assert(self._parser.nodes[node], "unknown node to jump to")
	self:write([[
		/* jump to gid %d */
		ctx.node = %d; break;
]], node.gid, self._parser.nodes[node])
end

function module.method:jumptoend(node)
	assert(self._parser, "parser not started")
	self:write[[
		ctx.node = FINISH; break;
]]
end

function module.method:apply_node(node)
	assert(self._parser, "cannot apply node without started parser")
	assert(node)


	self:push_stored(self:store(node), "node")
	self:write[[
		lua_getfield(L, -1, "_trace");            /* node:_trace */
		lua_pushvalue(L, -2);                     /* pass node as self */
		lua_getfield(L, PARSE_CTX, "iter");       /* parse_ctx.iter */
]]
	self:pcall(2, 0, "node:_trace(parse_ctx.iter)")

	self:write[[
		lua_getfield(L, -1, "_apply");            /* node:_apply */
		lua_pushvalue(L, -2);                     /* pass node as self */
		lua_pushvalue(L, PARSE_CTX);              /* parse_ctx */
]]

	self:pcall(2, 0, "node:_apply(parse_ctx)")

	self:write[[
		lua_remove(L, -1);                        /* remove node from stack */

]]
end

function module.method:compile()
	assert(not self._parser, "unfinished parser ", self._parsers[#self._parsers].name)

	-- Luaopen
	self:write([[

int luaopen_%s(lua_State *L)
{
	lua_newtable(L);
]], self._name)

	-- Expose all parser
	for _, value in pairs(self._parsers) do
		self:write([[
	lua_pushcfunction(L, parse_%s);
	lua_setfield(L, -2, "parse_%s");
]], value.name, value.name)
	end

	self:write[[
	return 1;
}
]]
	self._fd:close()

	-- Compile c grammar
	local flags = string.format("%s -I%s -I%s/haka/lua/", haka.config.ccomp.flags, haka.config.ccomp.include_path, haka.config.ccomp.include_path)
	local compile_command = string.format("%s %s -o %s %s", haka.config.ccomp.cc, flags, self._sofile, self._cfile)
	log.info("compiling grammar '%s': %s", self._name, compile_command)
	local ret = os.execute(compile_command)
	if not ret then
		error("grammar compilation failed `"..compile_command.."`")
	end

	return self._name
end

function module.method:write(string, ...)
	assert(self._fd, "uninitialized template")
	self._fd:write(string.format(string, ...))
end

return module
