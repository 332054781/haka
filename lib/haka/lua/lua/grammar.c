/* File automatically generated by Haka. DO NOT EDIT */
#include <assert.h>

#include <haka/error.h>
#include <haka/log.h>
#include <haka/string_utils.h>
#include <haka/lua/lua.h>
#include <haka/lua/state.h>
#include <haka/lua/parse_ctx.h>
#include <haka/luabinding.h>

/* grammar from {{name}} */

static REGISTER_LOG_SECTION(grammar);

{% if _swig then %}
extern void *lua_get_swigdata(void *ptr);
{% end %}

{% for _, parser in ipairs(_parsers) do %}
static const struct node_debug *node_debug_{{ parser.name }};

int parse_{{ parser.name }}
{% if _swig then %}
(lua_State *L)
{
	void *_ctx;
	struct parse_ctx *ctx;
	assert(lua_isuserdata(L, 1));
	_ctx = lua_touserdata(L, 1);
	ctx = (struct parse_ctx *)lua_get_swigdata(_ctx);
{% else %}
(struct parse_ctx *ctx)
{
{% end %}

	ctx->node_debug_data = node_debug_{{ parser.name }};

	if (ctx->error.isset) {
		if (parse_ctx_catch(ctx)) {
#ifdef HAKA_DEBUG
			char dump[101];
			char dump_safe[401];
			struct vbuffer_sub sub;
			vbuffer_sub_create_from_position(&sub, &ctx->error.iter, 100);
			safe_string(dump_safe, dump, vbuffer_asstring(&sub, dump, 101));

			LOG_DEBUG(grammar, "catched: parse error at byte %d for field %s in %s: %s",
			ctx->error.iter.meter, ctx->node_debug_data[ctx->error.node-1].id, ctx->node_debug_data[ctx->error.node-1].rule, ctx->error.desc);
			LOG_DEBUG(grammar, "parse error context: %s...", dump_safe);
#endif
		} else {
			char dump[101];
			char dump_safe[401];
			struct vbuffer_sub sub;
			vbuffer_sub_create_from_position(&sub, &ctx->error.iter, 100);
			safe_string(dump_safe, dump, vbuffer_asstring(&sub, dump, 101));

			LOG_DEBUG(grammar, "parse error at byte %d for field %s in %s: %s",
			ctx->error.iter.meter, ctx->node_debug_data[ctx->error.node-1].id, ctx->node_debug_data[ctx->error.node-1].rule, ctx->error.desc);
			LOG_DEBUG(grammar, "parse error context: %s...", dump_safe);
			ctx->run = false;
		}
	}

	int call = 0;
	while(ctx->run) {
		if (call != 0) break;

		switch(ctx->next) {

{%
local node = parser.dgraph
local stack = { node }
while node do
	table.remove(stack, 1)
	local gid = node.gid

	if parser.written_nodes[gid] then
		assert(parser.nodes[node], "unknown node to jump to")
%}
		/* jump to gid {{ gid }} */
		ctx->next = {{ parser.nodes[node] }};
		break;
{%
	else
		local id = parser:register(node)
		parser.written_nodes[gid] = true
%}
		/* gid {{ gid }} */
		case {{ id }}: /* in rule '{{ node.rule or "<unknown>"}}' field '{{ node.name or node.id }}' <{{ class.classof(node).name }}> */
		{
			/* Register next node */
			ctx->next = {{ id }};
			/* Call required lua */
			if (call != 0) break;

			/* Node start */
			ctx->current = {{ id }};

			{%
				local msg = node:_ctrace()
				if msg then
					msg = escape_string(msg)
					local id = parser.nodes[node]
			%}
#ifdef HAKA_DEBUG_GRAMMAR
			{
				char dump[21];
				char dump_safe[81];
				struct vbuffer_sub sub;
				vbuffer_sub_create_from_position(&sub, ctx->iter, 20);
				safe_string(dump_safe, dump, vbuffer_asstring(&sub, dump, 21));

				LOG_DEBUG(grammar, "in rule '%s' field %s gid {{ node.gid }}: %s\n\tat byte %d: %s...",
					node_debug_{{ parser.name }}[{{ id }}-1].rule,
					node_debug_{{ parser.name }}[{{ id }}-1].id,
					"{{ msg }}", ctx->iter->meter, dump_safe);
			}
#endif
			{% end %}

			{%
				local type = class.classof(node).name
				local ccall_lua = false
			%}

			{% if type == "DGCompoundStart" or type == "DGRecordStart" or
				  type == "DGTryStart" or type == "DGArrayStart" then %}

			ctx->compound_level++;

			{% if type ~= "DGCompoundStart" then ccall_lua = true end %}

			{% elseif type == "DGCompoundFinish" or type == "DGRecordFinish" or
					  type == "DGUnionFinish" or type == "DGTryFinish" or
					  type == "DGArrayFinish" then %}

			ctx->compound_level--;
			if (ctx->recurs_finish_level == ctx->compound_level && ctx->recurs_count > 0) {
				/* pop recursion */
				ctx->recurs_count--;
				ctx->next = ctx->recurs[ctx->recurs_count].node;
				ctx->recurs_finish_level = ctx->recurs[ctx->recurs_count].level;
				break;
			}

			{% if type ~= "DGCompoundFinish" then ccall_lua = true end %}

			{% elseif type == "DGUnionRestart" then %}

			parse_ctx_seekmark(ctx);

			{% elseif type == "DGRelease" then %}

			parse_ctx_unmark(ctx);

			{% elseif type == "DGBranch" then %}

			call = {{ ccomp:store(node:capply(ccomp, parser)) }};    /* selector */

			{% elseif type == "DGRecurs" then %}

			{% local id = parser:register(node._next) %}

			if (ctx->recurs_count >= RECURS_MAX) {
				error("max recursion reached");
				return 0;
			}
			ctx->recurs[ctx->recurs_count].node = {{ id }};
			/* Store laste recursion level so we can reuse it later */
			ctx->recurs[ctx->recurs_count].level = ctx->recurs_finish_level;
			ctx->recurs_finish_level = ctx->compound_level;
			ctx->recurs_count++;

			{% elseif type == "DGNumber" then %}

			{% local endian = node.endian == 'big' and 1 or 0 %}

			const int size = (ctx->bitoffset + {{ node.size }} + 7) >> 3;
			const int bit = (ctx->bitoffset + {{ node.size }}) & 0x7;
			const bool iscontinue = vbuffer_iterator_isvalid(&ctx->reg0_iter);

			struct vbuffer_iterator *iter = iscontinue ? &ctx->reg0_iter : ctx->iter;

			if (!vbuffer_iterator_check_available(iter, size, NULL) ) {
				if (vbuffer_iterator_iseof(iter)) {
					error("Not enought data");
					ctx->next = FINISH;
					break;
				}

				/* Need to wait for more data */
				if (!iscontinue) {
					vbuffer_iterator_copy(iter, &ctx->reg0_iter);

					/*if (ctx->retains.count == 0)*/ {
						vbuffer_iterator_mark(&ctx->reg0_iter, true);
					}
				}

				/* Move the iterator to the end */
				vbuffer_iterator_advance(ctx->iter, ALL);

				/* We now need to wait for more data */
				call = {{ ccomp.waitcall }};   /* waitcall(ctx) */
				break;
			}

			if (iscontinue) {
				vbuffer_iterator_unmark(iter);
			}

			vbuffer_sub_create_from_position(&ctx->reg0_sub, iter, size);
			vbuffer_iterator_advance(iter, size - (bit != 0 ? 1 : 0));

			if (iscontinue) {
				vbuffer_iterator_move(ctx->iter, iter);
				vbuffer_iterator_clear(&ctx->reg0_iter);
			}

			ctx->reg0_int = (ctx->bitoffset == 0 && bit == 0);
			ctx->reg1_int = ctx->bitoffset;
			ctx->bitoffset = bit;

			{% if node._post_apply then %}
				if (ctx->reg0_int) {
					ctx->reg0_long = vbuffer_asnumber(ctx->reg0_sub, {{ endian }});
				}
				else {
					ctx->reg0_long = vbuffer_asbits(ctx->reg0_sub, ctx->reg1_int,
							{{ node.size }}, {{ endian }});
				}
			{% end %}

			{% if node._post_apply or node.name then %}
				call = {{ ccomp:store(node:capply()) }};
			{% end %}

			{% else
				ccall_lua = true
			end %}

			{# Default: Token, Bytes, Bits, Retain, Execute, Error, ArrayPop, ArrayPush #}

			{% if ccall_lua then
				local node = node
			%}
				call = {{ ccomp:store(function (ctx) node:_apply(ctx) end) }}; /* node:_apply(ctx) */
			{% end %}
		}

{%
		local nexts = node:getnexts()
		if #nexts == 0 then
%}
			ctx->next = FINISH; break;
{%
		end

		table.prepend(stack, nexts)

	end

	node = stack[1]

end
%}
		default: /* node 0 is default and is also exit */
		{
			ctx->run = false;
		}
		}
	}

{% if _swig then %}
	lua_pushinteger(L, call);
	return 1;
{% else %}
	return call;
{% end %}
}

static const struct node_debug node_debug_{{ parser.name }}_init[] = {
{%
local id2node = {}

for node, id in pairs(parser.nodes) do
	id2node[id] = node
end

for id=1, parser.nodes_count do
	local node = id2node[id]
%}
	{ .id = "{{ node.name or node.id or "<unknown>" }}", .rule = "{{ node.rule or "<unknown>" }}" }, /* id: {{ id }}, gid: {{ node.gid }} */
{% end %}
};

{% end %}

/**
 * Generated lua byte code from:

{{ binding_code }}
 */
static const char luabc_{{ name }}[] = {
	{{ binding_bytecode }}
};

inline void lua_load_{{ name }}(lua_State *L)
{
	luaL_loadbuffer(L, luabc_{{ name }}, sizeof(luabc_{{ name }}), "{{ name }}");
}


LUA_BIND_INIT({{ nameid }})
{
	LUA_LOAD({{ name }}, L);

{% for _, parser in ipairs(_parsers) do %}
	node_debug_{{ parser.name }} = node_debug_{{ parser.name }}_init;
{% end %}

{% if _swig then %}
	lua_newtable(L);

	{% for _, parser in pairs(_parsers) do %}
	lua_pushstring(L, "parse_{{ parser.name }}");
	lua_pushcfunction(L, parse_{{ parser.name }});
	lua_settable(L, -3);
	{% end %}

	lua_call(L, 1, 1);
{% else %}
	lua_call(L, 0, 1);
{% end %}

	return 1;
}
