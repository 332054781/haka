/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

%import "haka/lua/config.si"

%include "haka/lua/swig.si"
%include "haka/lua/vbuffer.si"

%{
#include <haka/vbuffer.h>
#include <haka/lua/parse_ctx.h>

bool parse_ctx_geterror(struct parse_ctx *ctx, struct vbuffer_iterator **OUTPUT, const char **OUTPUT1, const char **OUTPUT2, const char **OUTPUT3)
{
	*OUTPUT = NULL;
	*OUTPUT1 = NULL;
	*OUTPUT2 = NULL;
	*OUTPUT3 = NULL;

	if (!ctx->error.isset) return false;

	*OUTPUT = malloc(sizeof(struct vbuffer_iterator));
	if (!(*OUTPUT)) {
		error("Memory error");
		return false;
	}
	vbuffer_iterator_copy(&ctx->error.iter, *OUTPUT);
	vbuffer_iterator_register(*OUTPUT);

	*OUTPUT1 = ctx->node_debug_data[ctx->error.node-1].id;
	*OUTPUT2 = ctx->node_debug_data[ctx->error.node-1].rule;
	*OUTPUT3 = ctx->error.desc;
	return true;
}

struct vbuffer_sub *parse_ctx_get_reg0_sub(struct parse_ctx *ctx)
{
	struct vbuffer_sub *sub = malloc(sizeof(struct vbuffer_sub));
	if (!sub) {
		error("Memory error");
		return NULL;
	}

	vbuffer_sub_copy(&ctx->reg0_sub, sub);
	vbuffer_sub_register(sub);
	return sub;
}

%}

%include "haka/lua/swig.si"
%include "haka/lua/object.si"
%include "haka/lua/vbuffer.si"

#ifdef HAKA_SWIG

%newobject parse_ctx::retain_mark;
%newobject parse_ctx::reg0_sub;

struct parse_ctx {
	int run;
	int next;
	int bitoffset;
	int reg0_int;
	int reg1_int;
	int reg0_long;

	%extend {
		parse_ctx(struct vbuffer_iterator_blocking *iter) {
			return parse_ctx_new(&iter->super);
		}

		parse_ctx(struct vbuffer_iterator *iter) {
			return parse_ctx_new(iter);
		}

		~parse_ctx() {
			parse_ctx_free($self);
		}

		void mark(bool readonly);
		void unmark();
		void pushmark();
		void popmark(bool seek = false);
		void seekmark();
		void error(const char desc[]);
		int  lookahead();

		struct vbuffer_iterator *retain_mark() {
			struct vbuffer_iterator *ret = malloc(sizeof(struct vbuffer_iterator));
			if (!ret) {
				error("memory error");
				return NULL;
			}

			if (parse_ctx_get_mark($self, ret)) {
				return ret;
			} else {
				free(ret);
				return NULL;
			}
		}

		bool geterror(struct vbuffer_iterator **OUTPUT, const char **OUTPUT1, const char **OUTPUT2, const char **OUTPUT3);

		%immutable;
		struct vbuffer_sub *reg0_sub {
			return parse_ctx_get_reg0_sub($self);
		}
	}
};

#else

FFI_OBJECT(struct parse_ctx);

bool parse_ctx_geterror(struct parse_ctx *ctx, struct vbuffer_iterator **OUTPUT, const char **OUTPUT1, const char **OUTPUT2, const char **OUTPUT3);

%newobject parse_ctx_get_reg0_sub;
struct vbuffer_sub *parse_ctx_get_reg0_sub(struct parse_ctx *ctx);

%luacode{
	haka.C.parse_ctx_geterror = haka.parse_ctx_geterror
	haka.parse_ctx_geterror = nil
	haka.C.parse_ctx_get_reg0_sub = haka.parse_ctx_get_reg0_sub
	haka.parse_ctx_get_reg0_sub = nil
}

#endif
